{
    "collab_server" : "",
    "contents" : "dataAwalFgwc <- reactive({\n  getdata()\n  # getUsernameFromDB()\n})\n\nresult <- reactiveValues()\ndat <- reactiveValues()\n\ndataFgwc <- reactive({\n    return(dat)\n})\n\n\noutput$fgwcGsa <- renderUI({\n  sidebarLayout(\n    sidebarPanel(\n      tags$head(tags$link(rel = \"stylesheet\", type=\"text/css\", href=\"style.css\")),\n      conditionalPanel(condition=\"$('html').hasClass('shiny-busy')\",\n                       tags$div(class=\"loading\")),\n      #Status data dan status tools\n      wellPanel(\n        HTML(paste(\"<label><strong>Menu:\", \"Soft Computing\",\"</strong></label>\")),\n        HTML(paste(\"<label><strong>Tool:\",isolate(input$nav_fast),\"</strong></label></br>\")),\n        HTML(paste(\"<label><strong>Data:\", input$datasets,\"</strong></label>\"))\n      ),\n      wellPanel(\n        bsCollapse(multiple = FALSE, open = \"collapsFgwcGsa0\", id = \"mainSidebar1FgwcGsa\",\n                   bsCollapsePanel(strong(\"Select Method\"),\n                                   radioButtons(\"isFgwcGsa\",\"Select Method:\",c(\"FGWC\"),selected = \"FGWC\"),\n                                   checkboxInput(\"isOptimizedGsa\",\"Optimasi dengan GSA\",value = TRUE),\n                                   value=\"collapsFgwcGsa0\"\n                   ),\n                   bsCollapsePanel(strong(\"Select Variable\"), \n                                   selectInput(\"variableFgwcGsa\", \"Choose one variable to plot:\", names(dataAwalFgwc()), multiple = FALSE),\n                                   selectInput(\"variableClustFgwcGsa\", \"Choose one or more variable to cluster:\", names(dataAwalFgwc()), multiple = TRUE,\n                                               selected = state_multvar(\"variableClustFgwcGsa\", dataAwalFgwc())),\n                                   helpText(\"*If empty, all variable will use to cluster\"),\n                                   value=\"collapsFgwcGsa3\"\n                   ),\n                   bsCollapsePanel(strong(\"Geographical Weigthed Options\"),\n                                   conditionalPanel(\"input.isFgwcGsa == 'FGWC'\",\n                                                    radioButtons(\"isUploadMapFgwcGsa\",\"Use map (shapefile)?\",c(\"No\",\"Yes\"),selected = \"Yes\"),\n                                                    wellPanel(\n                                                    conditionalPanel(\"input.isUploadMapFgwcGsa == 'Yes'\",\n                                                                     fileInput(\"mapFgwcGsa\",\"Choose your shapefile\",TRUE)\n                                                    ),\n                                                      conditionalPanel(\"input.isUploadMapFgwcGsa == 'No'\",\n                                                                       fileInput(\"distanceFgwcGsa\",\"Upload distance data\",FALSE),\n                                                                       fluidRow(\n                                                                         column(width = 6,\n                                                                                checkboxInput(\"isHeaderDistance\",\"Header\",value = TRUE)\n                                                                         ),\n                                                                         column(width = 6,\n                                                                                textInput(\"sepDataDistance\",\"Separator\",\",\"))\n                                                                       ),\n                                                                       tags$head(tags$style(type=\"text/css\", \"#sepDataDistance {width: 30px}\"))\n                                                      )\n                                                    ),\n                                                    wellPanel(\n                                                      fileInput(\"populasiFgwcGsa\",\"Upload population data\",multiple = FALSE),\n                                                      fluidRow(\n                                                        column(width = 6,\n                                                               checkboxInput(\"isHeaderPopulasi\",\"Header\",value = TRUE)\n                                                        ),\n                                                        column(width = 6,\n                                                               textInput(\"sepDataPop\",\"Separator\",\",\"))\n                                                      ),\n                                                      tags$head(tags$style(type=\"text/css\", \"#sepDataPop {width: 30px}\"))\n                                                    )\n                                                    \n                                   ),\n                                   # conditionalPanel(\"input.isFgwcGsa == 'FGWC_Non_Geo'\",\n                                   #                  HTML(\"<p>Generate in each iteration</p>\")\n                                   #                  \n                                   # ),\n                                   value=\"collapsFgwcGsa1\"\n                   ),\n                   bsCollapsePanel(strong(\"Cluster Parameter\"), \n                                   numericInput(\"maxIterFgwcGsa\", \"Maximum Number of Iterations:\", 100, min = 1, step = 1),\n                                   numericInput(\"epsilonFgwcGsa\", \"Error Tolerance:\", 0.0000001, min = 0.0000001, step = 0.0000001),\n                                   numericInput(\"jumlahKlasterFgwcGsa\", \"Number of Cluster:\", 2, min = 1, step = 1),\n                                   numericInput(\"pangkatFgwcGsa\", \"Weight:\", 2,min =1, step=0.1),\n                                   numericInput(\"aFgwcGsa\", \"a:\", 1,min =1, step=1),\n                                   numericInput(\"bFgwcGsa\", \"b:\", 1,min =1, step=1),\n                                   #diberi peringatan jika jumlah dari alfa+beta != 1\n                                   numericInput(\"alfaFgwcGsa\", \"alfa:\", 0.7,min =0, step=0.1),\n                                   numericInput(\"betaFgwcGsa\", \"beta:\", 0.3,min =0, step=0.1),\n                                   value=\"collapsFgwcGsa2\"\n                   )\n        )\n      ),\n      wellPanel(actionButton(\"startClusteringFgwcGsa\", \"Go!\"),\n                p(\"Click the button to start clustering\")\n      ),\n      #sidebar untuk generate report\n      wellPanel(\n        conditionalPanel(\"input.startClusteringFgwcGsa\",\n                         strong(\"Generate Your Report\"),\n                         radioButtons(\"formatFgwcGsa\", \"Document format:\", c(\"Word\",\"PDF\" ,\"HTML\")),\n                         downloadButton(\"downloadReportFgwcGsa\")\n        ),\n        helpText(strong(\"Share your report: \")),\n        bsButton(\"moTrigClusCM\", \"SHARE\", style = \"primary\", type = \"action\"),\n        bsButton(\"fgwcShareForum\", \"SHARE to Forum\", style = \"primary\", type = \"action\"),br(),br()\n      ),\n      bsModal(\"modalHelp\",\"Panduan Pengguan Modul Analisis\", trigger = \"linkPanduan\",size = \"large\",\n                 tabsetPanel(id=\"panduanPanel\",\n                            tabPanel(\"Melakukan Analisis Data\",\n                                            HTML(inclMD2(\"tools/help/fgwcGsa.md\"))             \n                            ),\n                            tabPanel(\"Fuzzy Geographically Weighted Clustering\"\n                            ),\n                            tabPanel(\"Gravitational Search Algorithm\"\n                            )\n                 )\n      ),\n      bsModal2(\"moClusCM\", \"Share Your Analysis\", trigger = \"moTrigClusCM\",\n               helpText(\"This feature allows you to share your analysis to 'Gallery Data'\"),\n               textInput(\"titleFCM\", strong(\"Title :\") , value = \"\"),br(),\n               textInput(\"authorFCM\", strong(\"Author :\") , value = \"\"),br(),\n               selectInput(\n                 inputId = \"categoryFCM\",\n                 label = h5(\"Specify category:\"),\n                 choices = list(\n                   \"Clustering\" = \"clustering\",\n                   \"Forecasting\" = \"forecasting\",\n                   \"Ridge Regression\" = \"ridge\",\n                   \"Survival\" = \"survival\",\n                   \"Tobit Regression\" = \"tobit\"),selectize = FALSE,\n                 selected = \"clustering\"),br(),\n               strong(\"Summary :\"),br(),\n               HTML('<textarea id=\"summaryFCM\" rows=\"5\" cols=\"20\", class = \"form-control\"></textarea>'), br(), br(),\n               strong(\"Plot :\"),br(),\n               selectInput(\"cMeansPlotTypeShare\", label = \"\", choices = c(\"Plot 1\", \"Plot 2\", \"Plot 3\"), selected = \"Plot 1\", multiple = FALSE),\n               plotOutput(\"cMeansPlotFunctionShareUI\"),br(),\n               bsAlert(\"modalAlert2\"),\n               footer = list(\n                 bsButton(\"shareClusCM\", \"Submit to Gallery\", style=\"primary\", type = \"action\"),\n                 tags$button(type = \"button\", class = \"btn btn-default\", 'data-dismiss' = \"modal\", \"Close\")\n               )),\n      bsModal2(\"popFgwcShareForum\", \"Share Your Analysis\", trigger = \"fgwcShareForum\",\n               helpText(\"This feature allows you to share your analysis to the Forum in the Fuzzy Clustering Subforum.\"),\n               bsAlert(\"modalAlert\"),\n               textInput(\"subjectFCMForum\", strong(\"Subject :\") , value = \"\"),br(),\n               strong(\"Summary :\"),br(),\n               HTML('<textarea id=\"summaryFCMForum\" rows=\"5\" cols=\"20\", class = \"form-control\"></textarea>'), br(), br(),\n               footer = list(\n                 bsButton(\"shareFgwcForum\", \"Submit to Forum\", style=\"primary\", type = \"action\"),\n                 tags$button(type = \"button\", class = \"btn btn-default\", 'data-dismiss' = \"modal\", \"Close\")\n               ))\n    ),\n    mainPanel(\n      fluidPage(\n        tabsetPanel(id=\"tabPanelFgwcGsa\",\n                    tabPanel(\"Data\",value = \"tabData\",br(),\n                             HTML('<p> Selamat Datang di modul analisis Fuzzy Gewographically Weighted Clustering FAST.\n                                  Bagi yang baru pertama kali menggunakan modul analisis ini silahkan <a id=\"linkPanduan\" href=\"#\" class=\"action-button shiny-bound-input\">\n                                  <b> baca panduan </b> </a> terlebih dahulu\n                                  agar terhindar kesalahan dalam menggunakan modul ini.</p>'),\n                             bsCollapse(id=\"summaryPanel\",\n                                        bsCollapsePanel(\"Data Overview\",\n                                                        wellPanel(style=\"overflow-y:scroll;max-width:900px;max-height:700px;background-color: white\",\n                                                                  dataTableOutput(\"showData\"))\n                                        ),\n                                        bsCollapsePanel(\"Population Overview\",\n                                                        wellPanel(style=\"overflow-y:scroll;max-width:900px;max-height:700px;background-color: white\",\n                                                                  dataTableOutput(\"showPopulation\"))\n                                        ),\n                                        bsCollapsePanel(\"Distance Overview\",\n                                                        wellPanel(style=\"overflow-y:scroll;max-width:900px;max-height:700px;background-color: white\",\n                                                                  dataTableOutput(\"showDistance\"))\n                                        )\n                             )\n                             ),\n                             \n                    tabPanel(\"Summary\",value = 'tabSummary',br(),\n                             bsCollapse(id=\"summaryPanel\",open = \"Summary Clustering\",\n                                        bsCollapsePanel(\"Summary Data\",\n                                                        wellPanel(style=\"overflow-y:scroll;max-width:900px;max-height:700px;background-color: white\",\n                                                                  tags$p(\"Summary Data :\", style=\"font-size:16pt\"),\n                                                                  dataTableOutput(\"summaryTable\"))\n                                                        ),\n                                        bsCollapsePanel(\"Summary Clustering\",\n                                                        # tableOutput(\"membershipTableFgwcGsa\")\n                                                        uiOutput(outputId = \"summaryFgwcGsa\")\n                                                        # plotOutput(\"plotFgwcGsa\")\n                                                        )\n                                        )\n                    ),\n                    tabPanel(\"Plot\",br(),\n                            bsCollapse(id=\"plotPanel\",multiple = TRUE,\n                                       bsCollapsePanel(\"Map Plot\",\n                                                       tabsetPanel(\"tabPlotMap\",\n                                                                   tabPanel(\"Variable\",\n                                                                            conditionalPanel(condition = \"output.mapUploaded == NULL\",\n                                                                                             tags$p(\"Input peta terlebih dahulu\",style=\"color: red\")\n                                                                            ),\n                                                                            conditionalPanel(condition = \"output.mapUploaded\",\n                                                                                             plotOutput(\"showMapFgwcGsa\")\n                                                                                             # plotOutput(\"showMapFgwcGsa\",hover = hoverOpts(id =\"plot_hover\"))\n                                                                            )\n                                                                            ),\n                                                                   tabPanel(\"Cluster\",\n                                                                            plotOutput(\"showPetaKlasterFgwcGsa\"),\n                                                                            conditionalPanel(condition = \"output.showPetaKlasterFgwcGsa != NULL\"\n                                                                                            # helpText(paste(\"Gerombol berdasarkan variabel\",input$variableClustFgwcGsa))\n                                                                            )\n                                                                            )\n                                                         \n                                                       ),\n                                                       value = \"mapPlotPanel\"\n                                                       ),\n                                       bsCollapsePanel(\"Cluster Plot\",\n                                                       conditionalPanel(\"output.clusterPlotOutput != NULL\",\n                                                                        plotOutput(\"clusterPlotOutput\")\n                                                       ),\n                                                       conditionalPanel(\"output.clusterPlotOutput == NULL\",\n                                                                        tags$p(\"Anda belum melakukan klasterisasi data\",style=\"color: red\")\n                                                       ),\n                                                       value = \"clustPlotPanel\"),\n                                       bsCollapsePanel(\"Radar Plot\",\n                                                       wellPanel(style=\"overflow-y:scroll;max-width:900px;max-height:700px;background-color: white\",\n                                                                 plotOutput(\"radarPlotOutput\")),\n                                                       value =\"biPlotPanel\"),\n                                       bsCollapsePanel(\"Bi Plot\",\n                                                       wellPanel(style=\"overflow-y:scroll;max-width:900px;max-height:700px;background-color: white\",\n                                                                           plotOutput(\"biPlotOutput\")),\n                                                       value =\"biPlotPanel\"),\n                                       bsCollapsePanel(\"Scatter Plot\",\n                                                       wellPanel(style=\"overflow-y:scroll;max-width:900px;max-height:700px;background-color: white\",\n                                                                 plotOutput(\"scatterPlotOutput\")),\n                                                       value =\"scatterPlot\")\n                                       )\n                    )\n                    \n        )\n      )\n    )\n  )\n})\n\n\n#summaryTable\n\noutput$summaryTable <- renderDataTable({\n  summary(dataAwalFgwc())\n},options = list(bSortClasses = TRUE, bCaseInsensitive = TRUE, \n                 aLengthMenu = c(10, 20, 30, 50), iDisplayLength = 10))\n\n#show data in modul menu\noutput$showData <- renderDataTable({\n  as.data.frame(dataAwalFgwc())\n},options = list(bSortClasses = TRUE, bCaseInsensitive = TRUE, \n                aLengthMenu = c(10, 20, 30, 50), iDisplayLength = 10)\n)\n\noutput$showPopulation <- renderDataTable({\n  as.data.frame(readInputPopulasiFgwcGsa())\n},options = list(bSortClasses = TRUE, bCaseInsensitive = TRUE, \n                 aLengthMenu = c(10, 20, 30, 50), iDisplayLength = 10)\n)\n\noutput$showDistance <- renderDataTable({\n  distance <- readInputDistanceFgwcGsa()\n  as.data.frame(distance)\n},options = list(bSortClasses = TRUE, bCaseInsensitive = TRUE, \n                 aLengthMenu = c(10, 20, 30, 50), iDisplayLength = 10)\n)\n\n#summary hasil analisis\noutput$summaryFgwcGsa <- renderUI({\n  list(\n    conditionalPanel(\"input.startClusteringFgwcGsa\",\n    wellPanel(HTML(\"Hasil cluster berdasarkan variabel\",names(dataFgwc()))),\n    tabsetPanel(id=\"tabPanelResultFgwcGsa\",\n                tabPanel(\"Membership\",\n                         fluidRow(\n                           column(width=12,\n                                  wellPanel(style=\"overflow-y:scroll;max-width:900px;max-height:700px;background-color: white\",\n                                            dataTableOutput(\"membershipTableFgwcGSa\"))\n                           )\n                        )\n                ),\n                tabPanel(\"Centroid\",\n                         fluidRow(\n                           column(width=12,\n                                  wellPanel(style=\"overflow-y:scroll;max-width:900px;max-height:700px;background-color: white\",\n                                            tableOutput(\"pusatKlasterTableFgwcGsa\"))\n                           )\n                         )\n                ),\n                tabPanel(\"Validation and Number Of Iterations\",\n                         fluidRow(\n                           column(width=12,\n                                  wellPanel(style=\"overflow-y:scroll;max-width:900px;max-height:700px;background-color: white\",\n                                            tableOutput(\"summaryValidationFgwcGsa\"))\n                           )\n                         )\n                )\n    )\n    )\n  )\n})\n\n\n##Pengecakan Input\nreadInputPopulasiFgwcGsa <- reactive({\n  if(!is.null(input$populasiFgwcGsa)){\n    inputTemp <- input$populasiFgwcGsa\n    #   if(input$isHeaderInputFgwcGsa){\n    #     input <- read.csv(inputTemp$datapath, header = T)\n    #   }else{\n    #     input <- read.csv(inputTemp$datapath, header = F)\n    #   }\n    input <- read.csv(inputTemp$datapath, header = input$isHeaderPopulasi,sep = input$sepDataPop)\n    return (input)\n  }else{\n    return(NULL)\n  }\n})\n\nreadInputDistanceFgwcGsa <- reactive({\n  if(!is.null(input$distanceFgwcGsa)){\n  inputTemp <- input$distanceFgwcGsa\n  #   if(input$isHeaderInputFgwcGsa){\n  #     input <- read.csv(inputTemp$datapath, header = T)\n  #   }else{\n  #     input <- read.csv(inputTemp$datapath, header = F)\n  #   }\n  input <- read.csv(inputTemp$datapath, header = input$isHeaderDistance,sep = input$sepDataDistance)\n  return (input)\n}else{\n  if(!is.null(uploadMapsFgwcGsa())){\n    peta <- uploadMapsFgwcGsa()\n    centroid <- gCentroid(peta,byid = T)\n    distance <- as.matrix(spDists(centroid, longlat=T))\n    rownames(distance) <- peta$KABKOT\n    colnames(distance) <- peta$KABKOT\n    return(distance)\n  }else{\n    return()\n  }\n}})\n\n##loadPeta\npetaFgwcGsa <- reactive({\n  data <- dataAwalFgwc()\n  dimensi <- dim(data)\n  value <- matrix(0, nrow=dimensi[1], byrow=T)\n  low.col <- \"green\"\n  high.col <- \"skyblue4\"\n  \n \n  if (!is.null(uploadMapsFgwcGsa())){\n    reg <- uploadMapsFgwcGsa()\n    \n    proj4string(reg) <- CRS(\"+init=epsg:4238\")\n    reg.wgs84 <- spTransform(reg, CRS(\"+init=epsg:4238\"))\n    reg@data$id <- as.numeric(rownames(reg@data)) + 1\n    id <- as.numeric(rownames(reg@data)) + 1\n    reg.f <- fortify(reg, region=\"id\")\n    \n    centroid.reg.f <- as.data.frame(coordinates(reg))\n    names(centroid.reg.f) <- c(\"Longitude\", \"Latitude\")\n    \n    #convert data dari factor > character > numeric\n    data <- data[,input$variableFgwcGsa]\n    data <- data.frame(lapply(data, as.character), stringsAsFactors=FALSE)\n    # \n    # #menentukan cut off data\n    # q1 <- quantile(value,probs = 0.25)\n    # q3 <- quantile(value,probs = 0.75)\n    # group <- c()\n    # for(i in 1:dimensi[1]){\n    #   value[i] <- as.numeric(sub(\",\", \".\", data[i], fixed = TRUE))\n    #   if(value[i]<= q1){\n    #     group <- cbind(group,c(\"Rendah\"))\n    #   }else{\n    #     if(value[i]>=q3){\n    #       group <- cbind(group,c(\"Tinggi\"))\n    #     }else{\n    #       group <- cbind(group,c(\"Sedang\"))\n    #     }\n    #   }\n    # }\n    # print(group)\n    \n    for(i in 1:dimensi[1]){\n      value[i] <- as.numeric(sub(\",\", \".\", data[i], fixed = TRUE))\n    }\n    \n    pop.df <- data.frame(id=id, Nilai=value, centroid.reg.f)  \n    Map1 <- ggplot(pop.df, aes(map_id=id)) \n    Map1 <- Map1 + geom_map(aes(fill=Nilai), map = reg.f, colour=\"grey23\")\n    Map1 <- Map1 + expand_limits(x = reg.f$long, y = reg.f$lat)\n    Map1 <- Map1 + coord_equal()\n    Map1 <- Map1 + geom_text(size=3, aes(label=id, x=Longitude, y=Latitude), color=\"white\")\n    Map1 <- Map1 + labs(x = \"Longitude\", y = \"Latitude\", title = paste(\"Visualisasi data variabel\",input$variableFgwcGsa)) + theme_bw()\n    Map1 <- Map1 + scale_fill_gradient(low=low.col, high=high.col)\n    return(Map1)\n  } else return()\n})\n\npetaKlasterFgwcGsa <- reactive({\n  if(!is.null(uploadMapsFgwcGsa()) && (!is.null(resultFgwcGsa()))){\n    reg2 <- uploadMapsFgwcGsa()\n    proj4string(reg2) <- CRS(\"+init=epsg:4238\")\n    reg2.wgs84 <- spTransform(reg2, CRS(\"+init=epsg:4238\"))\n    \n    reg2@data$id <- as.numeric(rownames(reg2@data)) + 1\n    id <- as.numeric(rownames(reg2@data)) + 1\n    reg2.f <- fortify(reg2, region=\"id\")\n    \n    centroid.reg2.f <- as.data.frame(coordinates(reg2))\n    names(centroid.reg2.f) <- c(\"Longitude\", \"Latitude\")\n    \n    value <- resultFgwcGsa()\n    cluster <- apply(value$membership, 1, which.max)\n    \n    cluster <- as.character(cluster)\n    #cluster <- data.frame(id=reg2@data$id, reg2@data$KAB_KOTA,cluster)\n    cluster <- data.frame(id=reg2@data$id, cluster)\n    \n    pop.df <- data.frame(id=id, cluster, centroid.reg2.f)  \n    Map1 <- ggplot(pop.df, aes(map_id=id))\n    Map1 <- Map1 + geom_map(aes(fill=cluster), map = reg2.f, colour=\"grey23\")\n    #disediakan 15 warna berbeda untuk tiap clusternya\n    Map1 <- Map1 + scale_fill_manual(values=c(\"1\"=\"paleturquoise4\",\n                                              \"2\"=\"dodgerblue2\",\n                                              \"3\"=\"green2\",\n                                              \"4\"=\"darkorange\",\n                                              \"5\"=\"purple\",\n                                              \"6\"=\"aquamarine4\",\n                                              \"7\"=\"yellow2\",\n                                              \"8\"=\"gold1\",\n                                              \"9\"=\"stateblue4\",\n                                              \"10\"=\"mediumpurple3\",\n                                              \"11\"=\"burlywood4\",\n                                              \"12\"=\"orangered1\",\n                                              \"13\"=\"plum4\",\n                                              \"14\"=\"snow4\",\n                                              \"15\"=\"indianred1\"))\n    Map1 <- Map1 + expand_limits(x = reg2.f$long, y = reg2.f$lat)\n    Map1 <- Map1 + coord_equal()\n    Map1 <- Map1 + geom_text(size=3, aes(label=id, x=Longitude, y=Latitude), color=\"white\")\n    Map1 <- Map1 + labs(x = \"Longitude\", y = \"Latitude\", title = \"Visualisasi Hasil Penggerombolan\") + theme_bw()\n    return(Map1)\n  }\n})\n\nuploadMapsFgwcGsa <- reactive({\n  if (!is.null(input$mapFgwcGsa)){\n    mapFile <- input$mapFgwcGsa\n    currentDirectory <- getwd()\n    uploadDirectory <- dirname(mapFile$datapath[1])\n    setwd(uploadDirectory)\n    for (i in 1:nrow(mapFile)){\n      file.rename(mapFile$datapath[i], mapFile$name[i])\n    }\n    \n    shpName <- mapFile$name[grep(x=mapFile$name, pattern=\"*.shp\")]\n    shpPath <- paste(uploadDirectory)\n    setwd(currentDirectory)\n    \n    #mendapatkan string shpName sebelum karakter \".\"\n    index <- lapply(strsplit(shpName, ''), function(shpName) which(shpName == '.'))[[1]]\n    name <- substr(shpName, 1, index-1)\n    shpFile <- readOGR(dsn=uploadDirectory, layer=name)\n    return(shpFile)\n  } else {\n    return(NULL)\n  }\n})\n\noutput$showMapFgwcGsa <- renderPlot({\n  map <- petaFgwcGsa()\n  return(map)\n})\n\noutput$showPetaKlasterFgwcGsa <- renderPlot({\n  map <- petaKlasterFgwcGsa()\n  return(map)\n})\n\noutput$mapUploaded <- reactive({\n  return(!is.null(uploadMapsFgwcGsa()))\n})\noutputOptions(output, 'mapUploaded', suspendWhenHidden=FALSE)\n\n# output$hover_info <- renderPrint({\n#   if(!is.null(input$plot_hover)){\n#     hover=input$plot_hover\n#     dist=sqrt((hover$x)^2+(hover$y)^2)\n#     data <- data()\n#     data <- data[,input$variableFgwcGsa]\n#     data[which.min(dist)]\n#     }\n# })\n\n##Call main function FGWCGSA\nrunFgwcGsa <- observeEvent(input$startClusteringFgwcGsa,{\n  datA <- getdata()\n  if(is.null(input$variableClustFgwcGsa)){\n    dat <<- datA\n  }else{\n    dat <<- datA[,as.character(input$variableClustFgwcGsa)]\n  }\n  result <<- calcaluteFgwcGsa()\n})\n\nresultFgwcGsa <- reactive({\n  return(result)\n})\n\ncalcaluteFgwcGsa <- function(){\n  \n  # validate(\n  #   need(as.numeric(input$alfaFgwcGsa)+as.numeric(input$betaFgwcGsa) == 1,\"alfa+beta must be 1\")\n  # )\n  # if(is.null(input$variableClustFgwcGsa)){\n  #   data <- data()\n  # }else{\n  #   data<-data()\n  #   data<-data[,as.character(input$varfcmabc)]\n  # }\n  \n  data <- dataFgwc()\n  \n  alfa <- input$alfaFgwcGsa\n  beta <- input$betaFgwcGsa\n  # \n  # validate(\n  #   need(alfa+beta == 1,\"alfa+beta must be 1\")\n  # )\n  \n  e <- input$epsilonFgwcGsa\n  maxIter <- input$maxIterFgwcGsa\n  a <- input$aFgwcGsa\n  b <- input$bFgwcGsa\n  m <- input$pangkatFgwcGsa\n  c <- input$jumlahKlasterFgwcGsa\n  if(input$isFgwcGsa == 'FGWC_Non_Geo'){\n    if(input$isOptimizedGsa){\n      \n    }else{\n      source(paste(getwd(),\"/tools/analysis/fgwc/FgwcNon-Habib.R\", sep=''))\n      hasil <- mFGWCNon(data, alfa, beta, e,maxIter, a, b, m, c)\n      hasil$validation <- getValidationFgwcGsa(data,hasil$membership,hasil$centroid,m)\n    }\n  }else{\n    if(input$isFgwcGsa == 'FGWC'){\n      #source(paste(getwd(),\"/tools/analysis/fgwc/FCMGSA.R\", sep=''))\n      population <- as.matrix(readInputPopulasiFgwcGsa())\n      # centroid <- gCentroid(uploadMapsFgwcGsa(),byid = T)\n      # distance <- as.matrix(spDists(centroid, longlat=T))\n      distance <- as.matrix(readInputDistanceFgwcGsa())\n      # result <- FCMGSA(data,maxIter,e,m,c)\n      if(input$isOptimizedGsa){\n        source(paste(getwd(),\"/tools/analysis/fgwc/FGWCGSA.R\", sep=''))\n        hasil <- FGWCGSA(data,population,distance,alfa,beta,e,maxIter,a,b,m,c)\n        # source(paste(getwd(),\"/tools/analysis/fgwc/fgwcgsaHabib.R\", sep=''))\n        # hasil <- mainGSAFGWC(data,population,distance,alfa,beta,e,maxIter,a,b,m,c)\n        hasil$validation <- getValidationFgwcGsa(data,hasil$membership,hasil$centroid,m)\n      }else{\n        source(paste(getwd(),\"/tools/analysis/fgwc/Fgwc-Habib.R\", sep=''))\n        hasil <- mFGWC(data, population, distance, alfa, beta, e,maxIter, a, b, m, c)\n        hasil$validation <- getValidationFgwcGsa(data,hasil$membership,hasil$centroid,m)\n      }\n    }\n  }\n  #result <- FCMGSA(data,population,distance,alfa,beta,e,maxIter,a,b,m,c)\n  return(hasil)\n}\n\ngetValidationFgwcGsa <- function(data,u,v,m){\n  source(paste(getwd(),\"/tools/analysis/fgwc/Evaluation.R\", sep=''))\n  PC <- partitionCoefficient(u)\n  CE <- classificationEntropy(u)\n  SC <- partitionIndex(data,u,v,m)\n  S <- separationIndex(data,u,v)\n  XB <- xieBeniIndex(data,u,v,m)\n  IFV <- ifvIndex(data,u,v)\n  data <- rbind(c(PC,CE,SC,S,XB,IFV))\n  colnames(data, do.NULL = FALSE)\n  colnames(data) <- c(\"Partition Coefficient\",\"Classification Entropy\",\"Partition Index\",\n                      \"Separation Index\",\"XieBeni Index\",\"IFV Index\")\n  return(data)\n}\n\n###Fungsi rendering table/plot/text hasil\noutput$biPlotOutput <- renderPlot({\n  if(is.null(dataFgwc()) && is.null(resultFgwcGsa()$membership)){\n    return()\n  }  \n  clust <- apply(resultFgwcGsa()$membership, 1, which.max)\n  rwname <- rownames(dataFgwc())\n  PCbiplot(prcomp(dataFgwc(), scale. = TRUE),clust = clust,rowname = rwname)\n})\n\noutput$clusterPlotOutput <- renderPlot({\n  if(is.null(dataFgwc()) && is.null(resultFgwcGsa()$membership)){\n    return()\n  }\n  library(cluster)\n  mh <- apply(resultFgwcGsa()$membership, 1, which.max)\n  clusplot(dataFgwc(), mh, color=TRUE, shade=TRUE,labels=11, lines=0)\n})\n\noutput$radarPlotOutput <- renderPlot({\n  if(is.null(dataFgwc()) && is.null(resultFgwcGsa()$membership)){\n    return()\n  }\n  clust <- apply(resultFgwcGsa()$membership, 1, which.max)\n  radarPlot(dataFgwc(),clust)\n})\n\noutput$scatterPlotOutput <- renderPlot({\n  if(is.null(dataFgwc())){\n    return()\n  }\n  pairs(dataFgwc(),lower.panel=panel.smooth, upper.panel=panel.cor,\n        pch=20, main=\" Scatterplot Matrix\")\n})\n\noutput$summaryValidationFgwcGsa <- renderTable({\n  if(is.null(resultFgwcGsa())){\n    return()\n  }\n  data <- resultFgwcGsa()$validation\n  Iterations <- resultFgwcGsa()$iterasi\n  data <- cbind(data,Iterations)\n  return(data)\n})\n\noutput$membershipTableFgwcGSa <- renderDataTable({\n  if(is.null(resultFgwcGsa())){\n    return()\n  }\n  data <- resultFgwcGsa()$membership\n  colnames(data) <- colnames(data,do.NULL = FALSE,prefix = \"Cluster\")\n  as.data.frame(data)\n},options = list(bSortClasses = TRUE, bCaseInsensitive = TRUE, \n                 aLengthMenu = c(10, 20, 30, 50), iDisplayLength = 10)\n)\n\n# output$partitionTableFgwcGsa <- renderTable({\n#   if(is.null(resultFgwcGsa())){\n#     return()\n#   }\n#   return(resultFgwcGsa()$membership)\n# })\n# \noutput$pusatKlasterTableFgwcGsa <- renderTable({\n  if(is.null(resultFgwcGsa())){\n    return()\n  }\n  data <- resultFgwcGsa()$centroid\n  colnames(data) <- colnames(data,do.NULL = FALSE,prefix = \"Var \")\n  rownames(data) <- rownames(data,do.NULL = FALSE,prefix = \"Cluster\")\n  data <- t(data)\n  return(data)\n})\n\noutput$plotFgwcGsa <- renderUI({\n  list(\n    uiOutput(\"renderPlotFgwcGsa\")\n  )\n})\n\n\n###############################\n#Kumpulan fungsi ke r markdwon#\n###############################\noutput$downloadReportFgwcGsa <- downloadHandler(\n  filename = function() {\n    paste('FGWC report', sep = '.', \n          switch(\n            input$formatFgwcGsa, PDF = 'pdf', HTML = 'html', Word = 'docx'\n          )\n    )\n  },\n  \n  content = function(file) {\n    src <- normalizePath('fgwc-gsa-report.Rmd')\n    \n    # temporarily switch to the temp dir, in case you do not have write\n    # permission to the current working directory\n    owd <- setwd(tempdir())\n    on.exit(setwd(owd))\n    file.copy(src, 'fgwc-gsa-report.Rmd')\n    \n    library(rmarkdown)\n    out <- render('fgwc-gsa-report.Rmd',\n                  params = list(summary = output$summaryTable),\n                  switch(\n                    input$formatFgwcGsa,\n                    PDF = pdf_document(),HTML = html_document(), Word = word_document()\n                  )\n    )\n    file.rename(out, file)\n  }\n)\n\n\nrawDataFgwcGsa <- function(){\n  as.data.frame(dataFgwc())\n}\n\nsummarayDataFgwcGsa <- function(){\n summary(dataFgwc())\n}\n\nhasilClusterFGwcGsa <- function(){\n  data <- resultFgwcGsa()$membership\n  colnames(data) <- colnames(data,do.NULL = FALSE,prefix = \"Cluster\")\n  as.data.frame(data)\n}\n\nindeksValiditasFgwcGsa <- function(){\n  data <- resultFgwcGsa()$validation\n  Iterations <- resultFgwcGsa()$iterasi\n  data <- cbind(data,Iterations)\n  return(data)\n}\n\nmapPlotFgwcGsa <- function(){\n  \n}\n\nclustPlotFgwcGsa <- function(){\n  library(cluster)\n  mh <- apply(resultFgwcGsa()$membership, 1, which.max)\n  clusplot(dataFgwc(), mh, color=TRUE, shade=TRUE,labels=11, lines=0)\n}\n\nradarPlotFgwcGsa <- function(){\n  \n}\n\nbiPlotFgwcGsa <- function(){\n  clust <- apply(resultFgwcGsa()$membership, 1, which.max)\n  rwname <- rownames(dataFgwc())\n  PCbiplot(prcomp(dataFgwc(), scale. = TRUE),clust = clust,rowname = rwname)\n}\n\nscatterPlotFgwcGsa <- function(){\n  if(is.null(dataFgwc())){\n    return()\n  }\n  pairs(dataFgwc(),lower.panel=panel.smooth, upper.panel=panel.cor,\n        pch=20, main=\" Scatterplot Matrix\")\n}\n\n\nradarPlot <- function(data,clust){\n  dataSplit <- split(data,clust)\n  \n  colmeanMatrix <- c()\n  for(i in 1:length(dataSplit)){\n    colmeanMatrix <- rbind(colmeanMatrix,colMeans(dataSplit[[i]]))\n  }\n  \n  colmeanMatrix <- scale(colmeanMatrix)\n  group <- c(1:length(dataSplit))\n  dataRadar <- c()\n  dataRadar <- cbind(dataRadar,group)\n  dataRadar <- cbind(dataRadar,colmeanMatrix)\n  plot <- CreateRadialPlot(dataRadar,grid.min = min(colmeanMatrix),grid.max = max(colmeanMatrix))\n  return(plot)\n}\n\n############################\n#Scatter Plot Correlatation#\n############################\npanel.cor <- function(x, y, digits=2, prefix=\"\", cex.cor, ...)\n{\n  usr <- par(\"usr\"); on.exit(par(usr))\n  par(usr = c(0, 1, 0, 1))\n  r <- abs(cor(x, y))\n  txt <- format(c(r, 0.123456789), digits=digits)[1]\n  txt <- paste(prefix, txt, sep=\"\")\n  if(missing(cex.cor)) cex.cor <- 0.8/strwidth(txt)\n  text(0.5, 0.5, txt, cex = 2)\n}\n\n\n\n############\n###BiPlot###\n############\n\nPCbiplot <- function(PC, x=\"PC1\", y=\"PC2\",clust,rowname) {\n  \n  # PC being a prcomp object\n  data <- data.frame(obsnames=rowname, PC$x)\n  clust <- as.character(clust)\n  data <- cbind(data,clust)\n  # plot <- plot + geom_hline(aes(0), size=.2) + geom_vline(aes(0), size=.2)\n  datapc <- data.frame(varnames=rownames(PC$rotation), PC$rotation)\n  mult <- min(\n    (max(data[,y]) - min(data[,y])/(max(datapc[,y])-min(datapc[,y]))),\n    (max(data[,x]) - min(data[,x])/(max(datapc[,x])-min(datapc[,x])))\n  )\n  datapc <- transform(datapc,\n                      V1 = .7 * mult * (get(x)),\n                      V2 = .7 * mult * (get(y))\n  )\n  ggplot(data, aes(x = PC1, y = PC2),label=TRUE) + geom_point() +\n    coord_equal(ratio = 1) +geom_text(data = datapc, aes(x = V1, y = V2, label = varnames), size = 3, vjust = 1) +\n    geom_segment(data = datapc, aes(x = 0, y=0, xend = V1, yend = V2),\n                 arrow = arrow(length = unit(0.1,\"cm\")),color = \"navy\") + geom_text(data = data, aes(group=clust,colour=clust,label = rowname))\n  \n}\n\n###########################\n########RADAR PLOT#########\n###########################\n\nCreateRadialPlot <- function(plot.data,\n                             axis.labels=colnames(plot.data)[-1],                             \n                             grid.min=-0.5,  #10,\n                             grid.mid=0,  #50,\n                             grid.max=0.5,  #100,\n                             centre.y=grid.min - ((1/9)*(grid.max-grid.min)),\n                             plot.extent.x.sf=1.2,\n                             plot.extent.y.sf=1.2,\n                             x.centre.range=0.02*(grid.max-centre.y),\n                             label.centre.y=FALSE,\n                             grid.line.width=0.5,\n                             gridline.min.linetype=\"longdash\",\n                             gridline.mid.linetype=\"longdash\",\n                             gridline.max.linetype=\"longdash\",\n                             gridline.min.colour=\"grey\",\n                             gridline.mid.colour=\"blue\",\n                             gridline.max.colour=\"grey\",\n                             grid.label.size=4,\n                             gridline.label.offset=-0.02*(grid.max-centre.y),\n                             label.gridline.min=TRUE,\n                             axis.label.offset=1.15,\n                             axis.label.size=3,\n                             axis.line.colour=\"grey\",\n                             group.line.width=1,\n                             group.point.size=4,\n                             background.circle.colour=\"yellow\",\n                             background.circle.transparency=0.2,\n                             plot.legend=if (nrow(plot.data)>1) TRUE else FALSE,\n                             legend.title=\"Cluster\",\n                             legend.text.size=grid.label.size ) {\n  \n  var.names <- colnames(plot.data)[-1]  #'Short version of variable names \n  #axis.labels [if supplied] is designed to hold 'long version' of variable names\n  #with line-breaks indicated using \\n\n  \n  #caclulate total plot extent as radius of outer circle x a user-specifiable scaling factor\n  plot.extent.x=(grid.max+abs(centre.y))*plot.extent.x.sf\n  plot.extent.y=(grid.max+abs(centre.y))*plot.extent.y.sf\n  \n  #Check supplied data makes sense\n  if (length(axis.labels) != ncol(plot.data)-1) \n    return(\"Error: 'axis.labels' contains the wrong number of axis labels\") \n  if(min(plot.data[,-1])<centre.y)\n    return(\"Error: plot.data' contains value(s) < centre.y\")\n  if(max(plot.data[,-1])>grid.max)\n    return(\"Error: 'plot.data' contains value(s) > grid.max\")\n  \n  #Declare required internal functions\n  \n  CalculateGroupPath <- function(df) {\n    #Converts variable values into a set of radial x-y coordinates\n    #Code adapted from a solution posted by Tony M to\n    #http://stackoverflow.com/questions/9614433/creating-radar-chart-a-k-a-star-plot-spider-plot-using-ggplot2-in-r\n    \n    #Args:\n    #  df: Col 1 -  group ('unique' cluster / group ID of entity)\n    #      Col 2-n:  v1.value to vn.value - values (e.g. group/cluser mean or median) of variables v1 to v.n\n    \n    path <- as.factor(as.character(df[,1]))\n    \n    ##find increment\n    angles = seq(from=0, to=2*pi, by=(2*pi)/(ncol(df)-1))\n    \n    ##create graph data frame\n    graphData= data.frame(seg=\"\", x=0,y=0)\n    graphData=graphData[-1,]\n    \n    for(i in levels(path)){\n      \n      pathData = subset(df, df[,1]==i)\n      \n      for(j in c(2:ncol(df))){\n        \n        #pathData[,j]= pathData[,j]\n        \n        graphData=rbind(graphData, data.frame(group=i, \n                                              x=pathData[,j]*sin(angles[j-1]),\n                                              y=pathData[,j]*cos(angles[j-1])))\n      }\n      ##complete the path by repeating first pair of coords in the path\n      graphData=rbind(graphData, data.frame(group=i, \n                                            x=pathData[,2]*sin(angles[1]),\n                                            y=pathData[,2]*cos(angles[1])))\n      \n    }\n    \n    #Make sure that name of first column matches that of input data (in case !=\"group\")\n    colnames(graphData)[1] <- colnames(df)[1]\n    \n    graphData #data frame returned by function\n    \n  }\n  \n  CaclulateAxisPath = function(var.names,min,max) {\n    #Caculates x-y coordinates for a set of radial axes (one per variable being plotted in radar plot)\n    \n    #Args:\n    #var.names - list of variables to be plotted on radar plot\n    #min - MININUM value required for the plotted axes (same value will be applied to all axes)\n    #max - MAXIMUM value required for the plotted axes (same value will be applied to all axes)\n    \n    #var.names <- c(\"v1\",\"v2\",\"v3\",\"v4\",\"v5\")\n    n.vars <- length(var.names) # number of vars (axes) required\n    \n    #Cacluate required number of angles (in radians)\n    angles <- seq(from=0, to=2*pi, by=(2*pi)/n.vars)\n    \n    #calculate vectors of min and max x+y coords\n    min.x <- min*sin(angles)\n    min.y <- min*cos(angles)\n    max.x <- max*sin(angles)\n    max.y <- max*cos(angles)\n    \n    #Combine into a set of uniquely numbered paths (one per variable)\n    axisData <- NULL\n    for (i in 1:n.vars) {\n      a <- c(i,min.x[i],min.y[i])\n      b <- c(i,max.x[i],max.y[i])\n      axisData <- rbind(axisData,a,b)\n    }\n    \n    #Add column names + set row names = row no. to allow conversion into a data frame\n    colnames(axisData) <- c(\"axis.no\",\"x\",\"y\")\n    rownames(axisData) <- seq(1:nrow(axisData))\n    \n    #Return calculated axis paths\n    as.data.frame(axisData)\n  }\n  \n  \n  funcCircleCoords <- function(center = c(0,0), r = 1, npoints = 100){\n    #Adapted from Joran's response to http://stackoverflow.com/questions/6862742/draw-a-circle-with-ggplot2\n    tt <- seq(0,2*pi,length.out = npoints)\n    xx <- center[1] + r * cos(tt)\n    yy <- center[2] + r * sin(tt)\n    return(data.frame(x = xx, y = yy))\n  }\n  \n  ### Convert supplied data into plottable format\n  \n  # (a) add abs(centre.y) to supplied plot data \n  #[creates plot centroid of 0,0 for internal use, regardless of min. value of y\n  # in user-supplied data]\n  plot.data.offset <- plot.data\n  plot.data.offset[,2:ncol(plot.data)]<- plot.data[,2:ncol(plot.data)]+abs(centre.y)\n  #print(plot.data.offset)\n  \n  # (b) convert into radial coords\n  group <-NULL\n  group$path <- CalculateGroupPath(plot.data.offset)\n  #print(group$path)\n  \n  # (c) Calculate coordinates required to plot radial variable axes\n  axis <- NULL\n  axis$path <- CaclulateAxisPath(var.names,grid.min+abs(centre.y),grid.max+abs(centre.y))\n  #print(axis$path)\n  \n  # (d) Create file containing axis labels + associated plotting coordinates\n  \n  #Labels\n  axis$label <- data.frame(\n    text=axis.labels,\n    x=NA,\n    y=NA )\n  #print(axis$label)\n  \n  #axis label coordinates\n  n.vars <- length(var.names)\n  angles = seq(from=0, to=2*pi, by=(2*pi)/n.vars)\n  axis$label$x <- sapply(1:n.vars, function(i, x) {((grid.max+abs(centre.y))*axis.label.offset)*sin(angles[i])})\n  axis$label$y <- sapply(1:n.vars, function(i, x) {((grid.max+abs(centre.y))*axis.label.offset)*cos(angles[i])})\n  #print(axis$label)\n  \n  # (e) Create Circular grid-lines + labels\n  \n  #caclulate the cooridinates required to plot circular grid-lines for three user-specified\n  #y-axis values: min, mid and max [grid.min; grid.mid; grid.max]\n  gridline <- NULL\n  gridline$min$path <- funcCircleCoords(c(0,0),grid.min+abs(centre.y),npoints = 360)\n  gridline$mid$path <- funcCircleCoords(c(0,0),grid.mid+abs(centre.y),npoints = 360)\n  gridline$max$path <- funcCircleCoords(c(0,0),grid.max+abs(centre.y),npoints = 360)\n  #print(head(gridline$max$path))\n  \n  #gridline labels\n  gridline$min$label <- data.frame(x=gridline.label.offset,y=grid.min+abs(centre.y),\n                                   text=as.character(grid.min))\n  gridline$max$label <- data.frame(x=gridline.label.offset,y=grid.max+abs(centre.y),\n                                   text=as.character(grid.max))\n  gridline$mid$label <- data.frame(x=gridline.label.offset,y=grid.mid+abs(centre.y),\n                                   text=as.character(grid.mid))\n  #print(gridline$min$label)\n  #print(gridline$max$label)\n  #print(gridline$mid$label)\n  \n  \n  ### Start building up the radar plot\n  \n  # Delcare 'theme_clear', with or without a plot legend as required by user\n  #[default = no legend if only 1 group [path] being plotted]\n  theme_clear <- theme_bw() + \n    theme(axis.text.y=element_blank(),\n          axis.text.x=element_blank(),\n          axis.ticks=element_blank(),\n          panel.grid.major=element_blank(),\n          panel.grid.minor=element_blank(),\n          panel.border=element_blank(),\n          legend.key=element_rect(linetype=\"blank\"))\n  \n  if (plot.legend==FALSE) theme_clear <- theme_clear + theme(legend.position=\"none\")\n  \n  #Base-layer = axis labels + plot extent\n  # [need to declare plot extent as well, since the axis labels don't always\n  # fit within the plot area automatically calculated by ggplot, even if all\n  # included in first plot; and in any case the strategy followed here is to first\n  # plot right-justified labels for axis labels to left of Y axis for x< (-x.centre.range)], \n  # then centred labels for axis labels almost immediately above/below x= 0 \n  # [abs(x) < x.centre.range]; then left-justified axis labels to right of Y axis [x>0].\n  # This building up the plot in layers doesn't allow ggplot to correctly \n  # identify plot extent when plotting first (base) layer]\n  \n  #base layer = axis labels for axes to left of central y-axis [x< -(x.centre.range)]\n  base <- ggplot(axis$label) + xlab(NULL) + ylab(NULL) + coord_equal() +\n    geom_text(data=subset(axis$label,axis$label$x < (-x.centre.range)),\n              aes(x=x,y=y,label=text),size=axis.label.size,hjust=1) +\n    scale_x_continuous(limits=c(-plot.extent.x,plot.extent.x)) + \n    scale_y_continuous(limits=c(-plot.extent.y,plot.extent.y))\n  \n  # + axis labels for any vertical axes [abs(x)<=x.centre.range]\n  base <- base + geom_text(data=subset(axis$label,abs(axis$label$x)<=x.centre.range),\n                           aes(x=x,y=y,label=text),size=axis.label.size,hjust=0.5)\n  \n  # + axis labels for any vertical axes [x>x.centre.range]\n  base <- base + geom_text(data=subset(axis$label,axis$label$x>x.centre.range),\n                           aes(x=x,y=y,label=text),size=axis.label.size,hjust=0)\n  \n  # + theme_clear [to remove grey plot background, grid lines, axis tick marks and axis text]\n  base <- base + theme_clear\n  \n  #  + background circle against which to plot radar data\n  base <- base + geom_polygon(data=gridline$max$path,aes(x,y),\n                              fill=background.circle.colour,\n                              alpha=background.circle.transparency)\n  \n  # + radial axes\n  base <- base + geom_path(data=axis$path,aes(x=x,y=y,group=axis.no),\n                           colour=axis.line.colour)\n  \n  # ... + group (cluster) 'paths'\n  base <- base + geom_path(data=group$path,aes(x=x,y=y,group=group,colour=group),\n                           size=group.line.width)\n  \n  # ... + group points (cluster data)\n  base <- base + geom_point(data=group$path,aes(x=x,y=y,group=group,colour=group),size=group.point.size)\n  \n  #... + amend Legend title\n  if (plot.legend==TRUE) base  <- base + labs(colour=legend.title,size=legend.text.size)\n  \n  # ... + circular grid-lines at 'min', 'mid' and 'max' y-axis values\n  base <- base +  geom_path(data=gridline$min$path,aes(x=x,y=y),\n                            lty=gridline.min.linetype,colour=gridline.min.colour,size=grid.line.width)\n  base <- base +  geom_path(data=gridline$mid$path,aes(x=x,y=y),\n                            lty=gridline.mid.linetype,colour=gridline.mid.colour,size=grid.line.width)\n  base <- base +  geom_path(data=gridline$max$path,aes(x=x,y=y),\n                            lty=gridline.max.linetype,colour=gridline.max.colour,size=grid.line.width)\n  \n  # ... + grid-line labels (max; ave; min) [only add min. gridline label if required]\n  if (label.gridline.min==TRUE) {\n    base <- base + geom_text(aes(x=x,y=y,label=text),data=gridline$min$label,fontface=\"bold\",size=grid.label.size, hjust=1) }\n  base <- base + geom_text(aes(x=x,y=y,label=text),data=gridline$mid$label,fontface=\"bold\",size=grid.label.size, hjust=1)\n  base <- base + geom_text(aes(x=x,y=y,label=text),data=gridline$max$label,fontface=\"bold\",size=grid.label.size, hjust=1)\n  \n  # ... + centre.y label if required [i.e. value of y at centre of plot circle]\n  if (label.centre.y==TRUE) {\n    centre.y.label <- data.frame(x=0, y=0, text=as.character(centre.y))\n    base <- base + geom_text(aes(x=x,y=y,label=text),data=centre.y.label,fontface=\"bold\",size=grid.label.size, hjust=0.5) }\n  \n  return(base)\n  \n}",
    "created" : 1466576744431.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1457536422",
    "id" : "1E668624",
    "lastKnownWriteTime" : 1469814162,
    "last_content_update" : 1469814162931,
    "path" : "E:/Coding/R/Skripsi/Fast-Modul-FgwcGsa/tools/analysis/fgwcGsa.R",
    "project_path" : "tools/analysis/fgwcGsa.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}